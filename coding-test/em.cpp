// https://docs.opencv.org/2.4/modules/ml/doc/expectation_maximization.html

#include "em.hpp"

typedef struct
{
	double delta = 0;
	double mean = 0;
} theta;

typedef struct
{
	double x;
	std::vector <double> z;
} y;

class data{
	public:
		std::vector <y> y_list; //state of samples
		std::vector <theta> theta_list; //list of params of mixture distribution
		std::vector < std::vector <double> > p_list; //list of probabilities of samples belonging to mixture
		std::vector <double> pi_list; //list of weights of mixture distribution
		int num_data, num_type; // number of samples and number of types of distribution
		double l_value = 0; // likelihood estimates of current params set
		bool break_flag = 0;
		int counter = 0;

		data(int num_data, int num_type);
		void update_prob(void);
		void update_params(void);
};

data::data(int num_data, int num_type)
{
	y_list.reserve(num_data);
	double mean, delta;
	y y_temp;

	//randomly generate uniformly distributed sample state and its model type as examples
 	for(int i = 0;i < num_data;++i)
 	{
 		y_temp.x = drand48()*10;
 		y_temp.z.reserve(num_type);
 		y_temp.z.resize(num_type,0);
 		y_temp.z[floor(drand48()*num_type)] = 1; //one hot encoding

 		y_list.push_back(y_temp);
 		mean += y_temp.x;
 	}
 	mean /= num_data;

 	//set inital params(delta and mean) of models as params of the whole sample set
 	for(int i = 0;i < num_data;++i)
 	{
 		delta += (y_list[i].x - mean)*(y_list[i].x - mean);
 	}
 	delta = sqrt(delta/num_data);

 	theta_list.reserve(num_type);
 	theta_list.resize(num_type);
 	for(int j = 0;j < num_type;++j)
 	{
 		theta_list[j].delta = delta;
 		theta_list[j].mean = mean;
 	}

 	//initialize probability list
 	p_list.reserve(num_data);
 	p_list.resize(num_data);
 	for(int i = 0;i < num_data;++i)
 	{
 		p_list.reserve(num_type);
 		p_list.resize(num_type);
 	}

 	//initialize weight list of mixtures
 	pi_list.reserve(num_type);
 	pi_list.resize(num_type,1/num_type);

 	//******************** main loop *****************
 	while(1)
 	{
 		std::cout << "count: " << counter << std::endl;
 		
 		// Expectation step: find a probability p_list(i,k) 
 		// of sample i to belong to mixture k 
 		// using the currently available mixture parameter estimates
 		update_prob();

 		if(break_flag == 1) break;

 		// Maximization step: the mixture parameter estimates 
 		// are refined using the computed probabilities
 		update_params();
 		// the final values are:
 		// theta_list(containing deltas and means) and pi_list(containing weights)
 		// of the distribution models

 		counter++;
 	}
 	//*************************************************

}

// Expectation step: find a probability p_list(i,k) 
// of sample i to belong to mixture k 
// using the currently available mixture parameter estimates
void data::update_prob(void)
{
	double p_temp, delta_temp, mean_temp, p_sum, l_value_temp;

	l_value_temp = 0;
	for(int i = 0;i < num_data;++i)
	{
		p_sum = 0;
		for(int j = 0;j < num_type;++j)
		{
			delta_temp = theta_list[j].delta;
			mean_temp = theta_list[j].mean;
			p_temp = gaussian_fun(y_list[i].x, delta_temp, mean_temp);	

			p_list[i][j] = p_temp * pi_list[j];
			p_sum += p_list[i][j];
		}

		for(int j = 0;j < num_type;++j)
		{
			p_list[i][j] /= p_sum;
		}
		l_value_temp += log(p_sum);
	}

	std::cout << "l_value_temp: " << std::setprecision(5) << l_value_temp << std::endl;

	// if the likelihood value start to drop, 
	// then we have found the max value, 
	// so break from main loop
	if(l_value >= l_value_temp)
	{
		break_flag = 1;
	} 
	else
	{
		l_value = l_value_temp;
	}
}

// Maximization step: the mixture parameter estimates 
// are refined using the computed probabilities
void data::update_params(void)
{
	double pi_sum, upper_sum, lower_sum;

	for(int j = 0;j < num_type;++j)
	{
		pi_sum = 0;
		for(int i = 0;i < num_data;++i)
		{
			pi_sum += p_list[i][j];
		}
		pi_list[j] = pi_sum/num_data;
	}

	for(int j = 0;j < num_type;++j)
	{
		upper_sum = lower_sum = 0;
		for(int i = 0;i < num_data;++i)
		{
			 upper_sum += p_list[i][j] * y_list[i].x;
			 lower_sum += p_list[i][j];
		}
		theta_list[j].mean = upper_sum / lower_sum; 
	}

	for(int j = 0;j < num_type;++j)
	{
		upper_sum = lower_sum = 0;
		for(int i = 0;i < num_data;++i)
		{
			upper_sum += p_list[i][j] * (y_list[i].x - theta_list[j].mean) * (y_list[i].x - theta_list[j].mean);
			lower_sum += p_list[i][j];
		}
		theta_list[j].delta = upper_sum / lower_sum;
	}

}

double gaussian_fun(double x_temp, double delta, double mean)
{

	double y;

	y = (1/(sqrt(2*M_PI)*delta)) * exp(-(x_temp - mean)*(x_temp - mean)/2/delta/delta);

	return y;

}


int main(void){

	// 1000 samples generated by 2 gaussian distribution models
	data data1(1000,2);

  	return 0;

}
